var documenterSearchIndex = {"docs":
[{"location":"binning/#Binning","page":"Binning","title":"Binning","text":"Often we want to bin the data (sum pixels) in microscopy","category":"section"},{"location":"binning/#MicroscopyTools.bin","page":"Binning","title":"MicroscopyTools.bin","text":"bin(arr, binning)\n\nBins a arr by the factors given in binning.\n\nFor efficient 2 binning, see bin2.\n\nExamples\n\nSimple Usage\n\njulia> bin([1 2 3 4; 5 6 7 8], (2, 2))\n1×2 Matrix{Int64}:\n 14  22\n\njulia> bin(ones((4, 4)), (2, 4))\n2×1 Matrix{Float64}:\n 8.0\n 8.0\n\njulia> bin([1,2,3,4,5], (2,))\n2-element Vector{Int64}:\n 3\n 7\n\nYou can leave out trailing 1s\n\njulia> bin(ones((2,2,2)), (2,))\n1×2×2 Array{Float64, 3}:\n[:, :, 1] =\n 2.0  2.0\n\n[:, :, 2] =\n 2.0  2.0\n\njulia> bin(ones((2,2,2)), (2,)) == bin(ones((2,2,2)), (2,1,1))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"binning/#MicroscopyTools.bin2","page":"Binning","title":"MicroscopyTools.bin2","text":"bin2(arr)\n\nEssentially calls bin(arr, (2,2)). However, works only for Union{AbstractArray{T, 2}, AbstractArray{T, 3}} where T since we use specialized methods of Tullio for that.\n\nExamples\n\njulia> x = [1 2 3 4; 5 6 7 8]\n2×4 Matrix{Int64}:\n 1  2  3  4\n 5  6  7  8\n\njulia> bin2(x)\n1×2 Matrix{Int64}:\n 14  22\n\njulia> bin2(x) ≈ bin(x, (2,2))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"grid_generation/#Grid-Generation","page":"Grid Generation","title":"Grid Generation","text":"These function provides help in generating scanning patterns","category":"section"},{"location":"grid_generation/#MicroscopyTools.regular_pattern","page":"Grid Generation","title":"MicroscopyTools.regular_pattern","text":"regular_pattern(sz; offset=0, step=1)\n\nReturns a generator with tuples that point to a regular grid pattern.\n\nArguments:\n\nsz: size of the underlaying array for which to generate the regular pattern\noffset: offset of the first position. Can be tuple or scalar.\nstep: step between the indices. Can be tuple or scalar.\n\nExamples\n\njulia> MicroscopyTools.regular_pattern((3,3))\nBase.Generator{CartesianIndices{2, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}}, MicroscopyTools.var\"#46#47\"{Int64, Int64}}(MicroscopyTools.var\"#46#47\"{Int64, Int64}(1, 1), CartesianIndex{2}[CartesianIndex(1, 1) CartesianIndex(1, 2) CartesianIndex(1, 3); CartesianIndex(2, 1) CartesianIndex(2, 2) CartesianIndex(2, 3); CartesianIndex(3, 1) CartesianIndex(3, 2) CartesianIndex(3, 3)])\n\njulia> collect(MicroscopyTools.regular_pattern((3,3)))\n3×3 Matrix{Tuple{Int64, Int64}}:\n (1, 1)  (1, 2)  (1, 3)\n (2, 1)  (2, 2)  (2, 3)\n (3, 1)  (3, 2)  (3, 3)\n\njulia> collect(MicroscopyTools.regular_pattern((3,3), step=2))\n2×2 Matrix{Tuple{Int64, Int64}}:\n (1, 1)  (1, 3)\n (3, 1)  (3, 3)\n\njulia> collect(MicroscopyTools.regular_pattern((3,3), step=2, offset=-1))\n2×2 Matrix{Tuple{Int64, Int64}}:\n (-1, -1)  (-1, 1)\n (1, -1)   (1, 1)\n\n\n\n\n\n","category":"function"},{"location":"calculation_tools/#Calculation-Tools","page":"Calculation Tools","title":"Calculation Tools","text":"Tools to help with microscopy-related calculations.","category":"section"},{"location":"calculation_tools/#MicroscopyTools.Δ_phase","page":"Calculation Tools","title":"MicroscopyTools.Δ_phase","text":"Δ_phase(arr, dim)\n\nCalculates the relative phase slope along dimension dim of a non-zero array arr without wrap-around problems.\n\nArguments:\n\narr: array of which to evaluate the phase slope\ndim: dimension along which to evaluate the slope\n\n\n\n\n\n","category":"function"},{"location":"calculation_tools/#MicroscopyTools.soft_theta","page":"Calculation Tools","title":"MicroscopyTools.soft_theta","text":"soft_theta(x::T, k=T(1)) where T\n\nThis is a version of the theta function that uses a soft transition and is differentiable. It is implemented as 1 / (1+exp(-2 * k * x)). A larger k makes the edge harder.\n\n\n\n\n\n","category":"function"},{"location":"calculation_tools/#MicroscopyTools.soft_theta_pw","page":"Calculation Tools","title":"MicroscopyTools.soft_theta_pw","text":"soft_theta_pw(x::T, ϵ=T(0.01)) where T\n\nA different version of the soft theta. Uses a cos instead of exp functions. Furthermore, is piecewise defined. A smaller e makes the edge harder.\n\n\n\n\n\n","category":"function"},{"location":"calculation_tools/#MicroscopyTools.radial_mean","page":"Calculation Tools","title":"MicroscopyTools.radial_mean","text":"radial_mean(data; maxbin=nothing, bin_step=nothing, pixelsize=nothing)\n\nCalculates the radial mean of a dataset data. Returns a tuple of the radialmean and the bincenters.\n\nArguments:\n\ndata: data to radially average\nmaxbin: a maximum bin value\nbin_step: optionally defines the step between the bins\n\nExamples\n\njulia> radial_mean([5, 1, 1, 3, 15])\n([1.0, 2.0, 10.0], [0.5, 1.5, 2.5])\n\n\n\n\n\n","category":"function"},{"location":"calculation_tools/#MicroscopyTools.soft_delta","page":"Calculation Tools","title":"MicroscopyTools.soft_delta","text":"soft_delta(x::T, k=T(1)) where T\n\nThis is a smooth version of the delta function that uses a soft peak and is differentiable. Based on a Gauss function. A larger k makes the edge harder.\n\n\n\n\n\n","category":"function"},{"location":"calculation_tools/#MicroscopyTools.soft_delta_pw","page":"Calculation Tools","title":"MicroscopyTools.soft_delta_pw","text":"soft_delta_pw(x::T, ϵ=T(1)) where T\n\nThis is a smooth version of the delta function that uses a soft peak and is differentiable. Based on a Gauss function. A larger k makes the edge harder.\n\n\n\n\n\n","category":"function"},{"location":"calculation_tools/#MicroscopyTools.moment_proj_normed","page":"Calculation Tools","title":"MicroscopyTools.moment_proj_normed","text":"moment_proj_normed(data, h=3; pdims=3)\n\nPerforms a projection over the h-th moment of the data along dimension(s) pdims normed by the variance.\n\nExample\n\njulia> MicroscopyTools.moment_proj_normed([1 3; 2 4], 2, pdims=(1,))\n1×2 Matrix{Float64}:\n 0.5  0\n\n\n\n\n\n","category":"function"},{"location":"calculation_tools/#MicroscopyTools.moment_proj","page":"Calculation Tools","title":"MicroscopyTools.moment_proj","text":"moment_proj(data, h=3; pdims=3)\n\nPerforms a projection over the h-th moment of the data along dimension(s) pdims. See also moment_proj_normed\n\nExample\n\njulia> MicroscopyTools.moment_proj([1 3; 2 4], 2, pdims=(1,))\n1×2 Matrix{Float64}:\n 0.25  0.25\n\n\n\n\n\n","category":"function"},{"location":"#MicroscopyTools.jl","page":"MicroscopyTools.jl","title":"MicroscopyTools.jl","text":"MicroscopyTools.jl is a package providing functionality often needed in microscopy. \n\nInstall MicroscopyTools.jl via the package manager.\n\njulia> add MicroscopyTools.jl\n\nCheck out the sub pages for different applications.","category":"section"}]
}
